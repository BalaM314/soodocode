import { Token } from "../lexer/lexer-types.js";
import { ExpressionAST, ExpressionASTNodeExt, ExpressionASTTypeNode, ProgramASTBranchNode, ProgramASTBranchNodeType, ProgramASTNodeGroup, TokenMatcher } from "../parser/parser-types.js";
import { StatementCheckTokenRange } from "../parser/parser.js";
import { PrimitiveVariableTypeName, TypedNodeValue, UntypedNodeValue, VariableType } from "../runtime/runtime-types.js";
import { Runtime } from "../runtime/runtime.js";
import { RangeArray, type IFormattable } from "../utils/funcs.js";
import type { TextRange, TextRanged } from "../utils/types.js";
import { StatementCategory, StatementExecutionResult, StatementType } from "./statement-types.js";
export declare class Statement implements TextRanged, IFormattable {
    nodes: RangeArray<ExpressionASTNodeExt>;
    type: typeof Statement;
    stype: StatementType;
    category: StatementCategory;
    range: TextRange;
    preRunDone: boolean;
    static type: StatementType;
    static category: StatementCategory;
    static example: string;
    static tokens: (TokenMatcher | "#")[];
    static evaluatableFields: string[];
    static suppressErrors: boolean;
    static blockType: ProgramASTBranchNodeType | null;
    static allowOnly: Set<StatementType> | null;
    static invalidMessage: string | null | ((parseOutput: StatementCheckTokenRange[], context: ProgramASTBranchNode | null) => [message: string, range?: TextRange]);
    constructor(nodes: RangeArray<ExpressionASTNodeExt>);
    token(ind: number): Token;
    tokens(from: number, to: number): RangeArray<Token>;
    tokenT<InputType extends PrimitiveVariableTypeName | VariableType>(ind: number, type: InputType): TypedNodeValue<Token, InputType>;
    expr(ind: number): ExpressionAST;
    expr(ind: number, allowed: "expr", error?: string): ExpressionAST;
    expr(ind: number, allowed: "type", error?: string): ExpressionASTTypeNode;
    expr<Type extends new (...args: any[]) => {}>(ind: number, allowed: Type[], error?: string): InstanceType<Type>;
    exprT(ind: number): UntypedNodeValue<ExpressionAST>;
    exprT<InputType extends PrimitiveVariableTypeName | VariableType>(ind: number, type: InputType): TypedNodeValue<ExpressionAST, InputType>;
    fmtText(): string;
    fmtDebug(): string;
    static blockEndStatement<TOut extends typeof Statement | Function = typeof Statement>(): typeof Statement extends TOut ? TOut : unknown;
    example(): string;
    static supportsSplit(block: ProgramASTBranchNode, statement: Statement): true | string;
    static checkBlock(block: ProgramASTBranchNode): void;
    static typeName(type?: StatementType): string;
    static tokensSortScore({ tokens, invalidMessage }?: typeof Statement): number;
    run(runtime: Runtime): void | StatementExecutionResult;
    runBlock(runtime: Runtime, node: ProgramASTBranchNode): void | StatementExecutionResult;
    static requiresScope: boolean;
    static interruptsControlFlow: boolean;
    static propagatesControlFlowInterruptions: boolean;
    preRun(group: ProgramASTNodeGroup, node?: ProgramASTBranchNode): void;
    triggerPreRun(group: ProgramASTNodeGroup, node?: ProgramASTBranchNode): void;
}
